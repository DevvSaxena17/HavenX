/**
 * Real-Time Data Manager for HavenX
 * Tracks actual user activities, sessions, and system metrics
 */

import CSVManager from './csvManager';
import toast from 'react-hot-toast';

export interface ActiveSession {
  id: string;
  userId: string;
  username: string;
  role: string;
  loginTime: string;
  lastActivity: string;
  ipAddress: string;
  userAgent: string;
  location: string;
  isActive: boolean;
  activityCount: number;
  pageViews: string[];
  actions: UserAction[];
}

export interface UserAction {
  id: string;
  userId: string;
  username: string;
  action: string;
  page: string;
  timestamp: string;
  details?: Record<string, unknown>;
  riskLevel: 'low' | 'medium' | 'high';
}

export interface SystemMetrics {
  timestamp: string;
  activeUsers: number;
  totalSessions: number;
  totalActions: number;
  loginAttempts: number;
  failedLogins: number;
  successfulLogins: number;
  threatEvents: number;
  riskScore: number;
  systemHealth: 'healthy' | 'warning' | 'critical';
}

export interface ThreatEvent {
  id: string;
  type: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  userId?: string;
  username?: string;
  timestamp: string;
  description: string;
  ipAddress?: string;
  location?: string;
  resolved: boolean;
  autoGenerated: boolean;
}

export interface User {
  id: string;
  username: string;
  role: string;
  name: string;
  email: string;
  department: string;
  securityScore: number;
  lastLogin: string;
  isActive: boolean;
}

class RealTimeDataManager {
  private static instance: RealTimeDataManager;
  private activeSessions: Map<string, ActiveSession> = new Map();
  private userActions: UserAction[] = [];
  private systemMetrics: SystemMetrics[] = [];
  private threatEvents: ThreatEvent[] = [];
  private csvManager: CSVManager;
  private metricsInterval?: number;
  private currentUser: User | null = null;

  constructor() {
    this.csvManager = CSVManager.getInstance();
    this.loadStoredData();
    this.startMetricsCollection();
  }

  public static getInstance(): RealTimeDataManager {
    if (!RealTimeDataManager.instance) {
      RealTimeDataManager.instance = new RealTimeDataManager();
    }
    return RealTimeDataManager.instance;
  }

  // Load data from localStorage
  private loadStoredData(): void {
    try {
      const storedSessions = localStorage.getItem('havenx_active_sessions');
      const storedActions = localStorage.getItem('havenx_user_actions');
      const storedMetrics = localStorage.getItem('havenx_system_metrics');
      const storedThreats = localStorage.getItem('havenx_threat_events');

      if (storedSessions) {
        const sessions = JSON.parse(storedSessions);
        sessions.forEach((session: ActiveSession) => {
          this.activeSessions.set(session.id, session);
        });
      }

      this.userActions = storedActions ? JSON.parse(storedActions) : [];
      this.systemMetrics = storedMetrics ? JSON.parse(storedMetrics) : [];
      this.threatEvents = storedThreats ? JSON.parse(storedThreats) : [];

      // Clean up old sessions (inactive for more than 30 minutes)
      this.cleanupInactiveSessions();
    } catch (error) {
      console.error('Error loading real-time data:', error);
    }
  }

  // Save data to localStorage
  private saveData(): void {
    try {
      localStorage.setItem('havenx_active_sessions', JSON.stringify(Array.from(this.activeSessions.values())));
      localStorage.setItem('havenx_user_actions', JSON.stringify(this.userActions));
      localStorage.setItem('havenx_system_metrics', JSON.stringify(this.systemMetrics));
      localStorage.setItem('havenx_threat_events', JSON.stringify(this.threatEvents));
    } catch (error) {
      console.error('Error saving real-time data:', error);
    }
  }

  // Start a session when user logs in
  public startSession(user: User): string {
    const sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const now = new Date().toISOString();

    const session: ActiveSession = {
      id: sessionId,
      userId: user.id,
      username: user.username,
      role: user.role,
      loginTime: now,
      lastActivity: now,
      ipAddress: this.getClientIP(),
      userAgent: navigator.userAgent,
      location: 'Office', // In real app, detect location
      isActive: true,
      activityCount: 0,
      pageViews: ['dashboard'],
      actions: []
    };

    this.activeSessions.set(sessionId, session);
    this.currentUser = user;
    this.recordAction('login', 'authentication', { message: 'User logged in successfully' });
    this.saveData();

    return sessionId;
  }

  // End a session when user logs out
  public endSession(sessionId: string): void {
    const session = this.activeSessions.get(sessionId);
    if (session) {
      session.isActive = false;
      this.recordAction('logout', 'authentication', { message: 'User logged out' });
      this.activeSessions.delete(sessionId);
      this.saveData();
    }
    this.currentUser = null;
  }

  // Record user action
  public recordAction(action: string, page: string, details?: Record<string, unknown>, riskLevel: 'low' | 'medium' | 'high' = 'low'): void {
    if (!this.currentUser) return;

    const actionId = `action_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const now = new Date().toISOString();

    const userAction: UserAction = {
      id: actionId,
      userId: this.currentUser.id,
      username: this.currentUser.username,
      action,
      page,
      timestamp: now,
      details,
      riskLevel
    };

    this.userActions.push(userAction);

    // Update active session
    const activeSession = Array.from(this.activeSessions.values())
      .find(s => s.userId === this.currentUser?.id && s.isActive);
    
    if (activeSession) {
      activeSession.lastActivity = now;
      activeSession.activityCount++;
      activeSession.actions.push(userAction);
      
      if (!activeSession.pageViews.includes(page)) {
        activeSession.pageViews.push(page);
      }
    }

    // Auto-generate threat events for suspicious activities
    this.checkForThreats(userAction);

    this.saveData();
  }

  // Record page view
  public recordPageView(page: string): void {
    this.recordAction('page_view', page, { page });
  }

  // Get real active users count
  public getActiveUsersCount(): number {
    this.cleanupInactiveSessions();
    return this.activeSessions.size;
  }

  // Get total registered users
  public getTotalUsersCount(): number {
    return this.csvManager.getAllUsers().length;
  }

  // Get active sessions
  public getActiveSessions(): ActiveSession[] {
    this.cleanupInactiveSessions();
    return Array.from(this.activeSessions.values()).filter(s => s.isActive);
  }

  // Get recent user actions
  public getRecentActions(limit: number = 50): UserAction[] {
    return this.userActions
      .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())
      .slice(0, limit);
  }

  // Get system metrics
  public getCurrentMetrics(): SystemMetrics {
    const loginRecords = this.csvManager.getLoginRecords();
    const recentLogins = loginRecords.filter(r => {
      const recordTime = new Date(r.timestamp);
      const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
      return recordTime > oneDayAgo;
    });

    const activeUsers = this.getActiveUsersCount();
    const totalSessions = this.activeSessions.size;
    const totalActions = this.userActions.length;
    const loginAttempts = recentLogins.length;
    const failedLogins = recentLogins.filter(r => r.status === 'failed').length;
    const successfulLogins = recentLogins.filter(r => r.status === 'success').length;
    const threatEvents = this.threatEvents.filter(t => !t.resolved).length;
    
    // Calculate risk score based on activities
    let riskScore = 50; // Base score
    if (failedLogins > 5) riskScore += 20;
    if (threatEvents > 0) riskScore += threatEvents * 5;
    if (activeUsers === 0) riskScore -= 10;
    
    riskScore = Math.min(Math.max(riskScore, 0), 100);

    const systemHealth = riskScore > 80 ? 'critical' : riskScore > 60 ? 'warning' : 'healthy';

    return {
      timestamp: new Date().toISOString(),
      activeUsers,
      totalSessions,
      totalActions,
      loginAttempts,
      failedLogins,
      successfulLogins,
      threatEvents,
      riskScore,
      systemHealth
    };
  }

  // Get threat events
  public getThreatEvents(): ThreatEvent[] {
    return this.threatEvents
      .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
  }

  // Get unresolved threats count
  public getActiveThreatsCount(): number {
    return this.threatEvents.filter(t => !t.resolved).length;
  }

  // Add manual threat event
  public addThreatEvent(
    type: string,
    severity: 'low' | 'medium' | 'high' | 'critical',
    description: string,
    userId?: string,
    username?: string
  ): void {
    const threat: ThreatEvent = {
      id: `threat_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type,
      severity,
      userId,
      username,
      timestamp: new Date().toISOString(),
      description,
      ipAddress: this.getClientIP(),
      location: 'Office',
      resolved: false,
      autoGenerated: false
    };

    this.threatEvents.push(threat);
    this.saveData();

    // Show toast notification for high/critical threats
    if (severity === 'high' || severity === 'critical') {
      toast.error(`${severity.toUpperCase()} threat detected: ${description}`);
    }
  }

  // Auto-check for threats based on user actions
  private checkForThreats(action: UserAction): void {
    const recentActions = this.userActions.filter(a => {
      const actionTime = new Date(a.timestamp);
      const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);
      return actionTime > fiveMinutesAgo && a.userId === action.userId;
    });

    // Multiple rapid actions (potential bot)
    if (recentActions.length > 20) {
      this.addThreatEvent(
        'Suspicious Activity',
        'high',
        `User ${action.username} performed ${recentActions.length} actions in 5 minutes`,
        action.userId,
        action.username
      );
    }

    // Failed login attempts
    if (action.action === 'failed_login') {
      const failedAttempts = recentActions.filter(a => a.action === 'failed_login').length;
      if (failedAttempts >= 3) {
        this.addThreatEvent(
          'Brute Force Attack',
          'critical',
          `${failedAttempts} failed login attempts for user ${action.username}`,
          action.userId,
          action.username
        );
      }
    }

    // Data export activities
    if (action.action.includes('export') || action.action.includes('download')) {
      this.addThreatEvent(
        'Data Export',
        'medium',
        `User ${action.username} exported data: ${JSON.stringify(action.details)}`,
        action.userId,
        action.username
      );
    }
  }

  // Clean up inactive sessions (older than 30 minutes)
  private cleanupInactiveSessions(): void {
    const thirtyMinutesAgo = new Date(Date.now() - 30 * 60 * 1000);
    
    for (const [sessionId, session] of this.activeSessions) {
      const lastActivity = new Date(session.lastActivity);
      if (lastActivity < thirtyMinutesAgo) {
        session.isActive = false;
        this.activeSessions.delete(sessionId);
      }
    }
    
    this.saveData();
  }

  // Start metrics collection interval
  private startMetricsCollection(): void {
    // Collect metrics every 30 seconds
    this.metricsInterval = window.setInterval(() => {
      const metrics = this.getCurrentMetrics();
      this.systemMetrics.push(metrics);
      
      // Keep only last 1000 metrics (about 8 hours of data)
      if (this.systemMetrics.length > 1000) {
        this.systemMetrics = this.systemMetrics.slice(-1000);
      }
      
      this.saveData();
    }, 30000);
  }

  // Get client IP (mock for demo)
  private getClientIP(): string {
    // In a real application, you would get this from the server
    return `192.168.1.${Math.floor(Math.random() * 254) + 1}`;
  }

  // Get historical metrics for charts
  public getMetricsHistory(hours: number = 24): SystemMetrics[] {
    const cutoffTime = new Date(Date.now() - hours * 60 * 60 * 1000);
    return this.systemMetrics.filter(m => new Date(m.timestamp) > cutoffTime);
  }

  // Get user activity statistics
  public getUserActivityStats(): {
    topUsers: { username: string; actionCount: number; riskLevel: string }[];
    actionsByHour: { hour: string; count: number }[];
    actionsByType: { type: string; count: number }[];
  } {
    const last24Hours = this.userActions.filter(a => {
      const actionTime = new Date(a.timestamp);
      const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
      return actionTime > oneDayAgo;
    });

    // Top active users
    const userStats = new Map<string, { count: number; riskLevels: string[] }>();
    last24Hours.forEach(action => {
      const existing = userStats.get(action.username) || { count: 0, riskLevels: [] };
      existing.count++;
      existing.riskLevels.push(action.riskLevel);
      userStats.set(action.username, existing);
    });

    const topUsers = Array.from(userStats.entries())
      .map(([username, stats]) => ({
        username,
        actionCount: stats.count,
        riskLevel: stats.riskLevels.includes('high') ? 'high' : 
                   stats.riskLevels.includes('medium') ? 'medium' : 'low'
      }))
      .sort((a, b) => b.actionCount - a.actionCount)
      .slice(0, 10);

    // Actions by hour
    const actionsByHour = new Map<string, number>();
    last24Hours.forEach(action => {
      const hour = new Date(action.timestamp).getHours();
      const hourKey = `${hour}:00`;
      actionsByHour.set(hourKey, (actionsByHour.get(hourKey) || 0) + 1);
    });

    // Actions by type
    const actionsByType = new Map<string, number>();
    last24Hours.forEach(action => {
      actionsByType.set(action.action, (actionsByType.get(action.action) || 0) + 1);
    });

    return {
      topUsers,
      actionsByHour: Array.from(actionsByHour.entries()).map(([hour, count]) => ({ hour, count })),
      actionsByType: Array.from(actionsByType.entries()).map(([type, count]) => ({ type, count }))
    };
  }

  // Clear all data (for testing/reset)
  public clearAllData(): void {
    this.activeSessions.clear();
    this.userActions = [];
    this.systemMetrics = [];
    this.threatEvents = [];
    this.saveData();
  }

  // Set current user (for tracking)
  public setCurrentUser(user: User): void {
    this.currentUser = user;
  }

  // Cleanup on app close
  public cleanup(): void {
    if (this.metricsInterval) {
      clearInterval(this.metricsInterval);
    }
  }
}

export default RealTimeDataManager;
